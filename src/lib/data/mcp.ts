import { randomBytes } from "crypto";
import bcrypt from "bcryptjs";

import type { ToolBlueprintDetail } from "@/lib/data/tool-blueprints";
import type { ToolDraft } from "@/lib/types/tooling";
import { getSupabaseAdminClient } from "@/lib/supabase/server";
import { ensureMaxLength, toKebabCase } from "@/lib/utils/string";

type PublishResult = {
  instance: {
    id: string;
    slug: string;
    display_name?: string;
  };
  apiKey: string | null;
  endpoint: string;
  discovery: unknown;
  capabilities: unknown;
};

const DEFAULT_ORGANIZATION_ID = process.env.DEFAULT_ORGANIZATION_ID ?? "demo-org";

const DEFAULT_MCP_VERSION = "2025-06-18";

export interface PublishBlueprintOptions {
  baseUrl?: string;
  organizationId?: string;
  requireKey?: boolean;
}

export async function publishBlueprintToMcp(
  blueprint: ToolBlueprintDetail,
  options: PublishBlueprintOptions = {},
): Promise<PublishResult> {
  if (!blueprint.tools.length) {
    throw new Error("Blueprint has no tools to publish.");
  }

  const supabase = getSupabaseAdminClient();
  const organizationId = options.organizationId ?? DEFAULT_ORGANIZATION_ID;
  const baseUrl = (options.baseUrl ?? process.env.MCP_BASE_URL ?? "http://localhost:8787").replace(/\/$/, "");
  const requireKey = options.requireKey ?? false;

  const apiKey = requireKey ? createApiKey() : null;
  const apiKeyHash = requireKey && apiKey ? await bcrypt.hash(apiKey, 10) : null;

  const slugBase = ensureMaxLength(toKebabCase(blueprint.label || "nexi-mcp"), 48);
  const slug = `${slugBase}-${shortId()}`;
  const displayName = blueprint.label || "Nexi MCP";
  const endpoint = `${baseUrl}/mcp/${slug}`;

  const capabilities = buildCapabilities();
  const discovery = buildDiscoveryPayload({ blueprint, endpoint, displayName, capabilities, requireKey });

  const { data: instance, error: instanceError } = await supabase
    .from("mcp_instances")
    .insert({
      slug,
      display_name: displayName,
      organization_id: organizationId,
      blueprint_id: blueprint.id,
      base_url: endpoint,
      status: "active",
      api_key_hash: apiKeyHash,
      capabilities,
      discovery_payload: discovery,
    })
    .select("id, slug, display_name")
    .single();

  if (instanceError) {
    throw instanceError;
  }

  const toolRecords = blueprint.tools.map((tool, index) => ({
    mcp_instance_id: instance.id,
    name: tool.name,
    version: `1.0.${index + 1}`,
    schema: tool.inputSchema,
    output_schema: tool.outputSchema ?? null,
    description: tool.description,
    instructions: buildInstructions({ tool, endpoint, requireKey }),
    is_active: true,
    metadata: {
      method: tool.method,
      path: tool.path,
      httpConfig: tool.httpConfig ?? null,
    },
  }));

  const { error: toolError } = await supabase.from("tool_versions").insert(toolRecords);
  if (toolError) {
    throw toolError;
  }

  return {
    instance,
    apiKey,
    endpoint,
    discovery,
    capabilities,
  };
}

function createApiKey() {
  return randomBytes(32).toString("base64url");
}

function shortId() {
  return randomBytes(4).toString("hex");
}

function buildCapabilities() {
  return {
    tools: {
      listChangedNotification: true,
      callTool: {
        resultStreaming: false,
      },
    },
    resources: {
      listChangedNotification: false,
    },
    prompts: {
      listChangedNotification: false,
    },
    logging: {
      levels: ["error", "warn", "info"],
    },
  };
}

function buildDiscoveryPayload({
  blueprint,
  endpoint,
  displayName,
  capabilities,
  requireKey,
}: {
  blueprint: ToolBlueprintDetail;
  endpoint: string;
  displayName: string;
  capabilities: unknown;
  requireKey: boolean;
}) {
  return {
    version: DEFAULT_MCP_VERSION,
    server: {
      name: displayName,
      description: `Generated by Nexi on ${new Date().toISOString()}`,
      transports: [
        {
          type: "http",
          endpoint,
          ...(requireKey
            ? {
                authentication: {
                  scheme: "bearer",
                  description: "Include the provided API key in the Authorization header",
                },
              }
            : {}),
        },
      ],
      capabilities,
      tools: blueprint.tools.map((tool) => ({
        name: tool.name,
        description: tool.description,
        method: tool.method,
        path: tool.path,
      })),
    },
  };
}

function buildInstructions({
  tool,
  endpoint,
  requireKey,
}: {
  tool: Omit<ToolDraft, "rawOperation">;
  endpoint: string;
  requireKey: boolean;
}) {
  return [
    `Invoke this tool to call ${tool.method.toUpperCase()} ${tool.path} on the upstream service.`,
    `Send arguments that satisfy the stored input schema; Nexi validates them before forwarding.`,
    requireKey
      ? `Include the provided API key as a Bearer token when calling ${endpoint}.`
      : `This endpoint is publicly accessible at ${endpoint}.`,
  ].join(" ");
}
